# -*- coding: utf-8 -*-
"""i2a2agentenf.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/gist/poraape/0e97142e8bca6c4f1ffd5ccd91264956/i2a2agentenf.ipynb
"""

!pip install streamlit pandas google-generativeai python-dotenv pyngrok

from google.colab import userdata
import os

# Carrega a chave do gerenciador de segredos do Colab
os.environ['GOOGLE_API_KEY'] = userdata.get('GOOGLE_API_KEY')

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# 
# import streamlit as st
# import pandas as pd
# import os
# import zipfile
# import google.generativeai as genai
# 
# # --- ConfiguraÃ§Ã£o do Modelo Gemini ---
# # A API Key jÃ¡ foi configurada como variÃ¡vel de ambiente no Colab
# try:
#     GOOGLE_API_KEY = os.environ.get("GOOGLE_API_KEY")
#     genai.configure(api_key=GOOGLE_API_KEY)
#     model = genai.GenerativeModel('gemini-1.5-flash')
# except Exception as e:
#     st.error(f"Erro ao configurar a API do Gemini. Verifique se a API Key estÃ¡ correta nos Secrets do Colab. Detalhes: {e}")
#     st.stop()
# 
# 
# # --- FunÃ§Ãµes "Ferramenta" do nosso Agente ---
# 
# def descompactar_arquivo(caminho_zip, pasta_destino):
#     """Ferramenta 1: Descompacta um arquivo .zip para uma pasta de destino."""
#     if not os.path.exists(pasta_destino):
#         os.makedirs(pasta_destino)
#     try:
#         with zipfile.ZipFile(caminho_zip, 'r') as zip_ref:
#             zip_ref.extractall(pasta_destino)
#         st.info(f"Arquivo descompactado em '{pasta_destino}'")
#         return pasta_destino
#     except Exception as e:
#         st.error(f"Erro ao descompactar o arquivo: {e}")
#         return None
# 
# def encontrar_csv(pasta):
#     """Ferramenta 2: Encontra o primeiro arquivo .csv em uma pasta."""
#     try:
#         for arquivo in os.listdir(pasta):
#             if arquivo.lower().endswith('.csv'):
#                 caminho_completo = os.path.join(pasta, arquivo)
#                 st.info(f"Arquivo CSV encontrado: '{arquivo}'")
#                 return caminho_completo
#     except Exception as e:
#         st.error(f"Erro ao procurar o arquivo CSV: {e}")
#     return None
# 
# def carregar_dados(caminho_csv):
#     """Ferramenta 3: Carrega os dados de um CSV para um DataFrame Pandas."""
#     try:
#         df = pd.read_csv(caminho_csv, encoding='utf-8', on_bad_lines='skip')
#     except UnicodeDecodeError:
#         df = pd.read_csv(caminho_csv, encoding='latin1', on_bad_lines='skip')
#     st.success("Dados carregados com sucesso!")
#     return df
# 
# # --- Interface GrÃ¡fica (Streamlit) ---
# 
# st.set_page_config(layout="wide", page_title="Agente CSV-Analyst")
# st.title("ğŸ¤– Agente CSV-Analyst")
# st.write("FaÃ§a o upload de um arquivo .zip contendo um CSV e faÃ§a uma pergunta sobre seus dados.")
# 
# PASTA_UPLOADS = "uploads"
# PASTA_DADOS = "dados_descompactados"
# 
# if not os.path.exists(PASTA_UPLOADS):
#     os.makedirs(PASTA_UPLOADS)
# 
# arquivo_zip_carregado = st.file_uploader(
#     "1. FaÃ§a o upload do seu arquivo .zip", type=['zip']
# )
# 
# pergunta_usuario = st.text_input(
#     "2. FaÃ§a sua pergunta em linguagem natural sobre os dados do CSV"
# )
# 
# if st.button("Analisar e Responder"):
#     if arquivo_zip_carregado is not None and pergunta_usuario:
#         with st.spinner("O Agente estÃ¡ trabalhando... æ€è€ƒä¸­..."):
#             caminho_zip = os.path.join(PASTA_UPLOADS, arquivo_zip_carregado.name)
#             with open(caminho_zip, "wb") as f:
#                 f.write(arquivo_zip_carregado.getbuffer())
# 
#             pasta_descompactada = descompactar_arquivo(caminho_zip, PASTA_DADOS)
# 
#             if pasta_descompactada:
#                 caminho_csv = encontrar_csv(pasta_descompactada)
# 
#                 if caminho_csv:
#                     df = carregar_dados(caminho_csv)
#                     st.write("Amostra dos dados:")
#                     st.dataframe(df.head())
# 
#                     st.info("Agente: Usando Gemini para gerar o cÃ³digo de anÃ¡lise...")
# 
#                     prompt_gerador_codigo = f"""
#                     VocÃª Ã© um especialista em anÃ¡lise de dados com Python e Pandas.
#                     O usuÃ¡rio tem um DataFrame pandas chamado `df`.
#                     As colunas do DataFrame sÃ£o: {list(df.columns)}
#                     A pergunta do usuÃ¡rio Ã©: "{pergunta_usuario}"
# 
#                     Sua tarefa Ã© gerar APENAS o cÃ³digo Python (usando o DataFrame `df`) que responde a essa pergunta.
#                     O resultado final do seu cÃ³digo deve ser armazenado em uma variÃ¡vel chamada `resultado`.
#                     NÃ£o inclua explicaÃ§Ãµes, apenas o cÃ³digo. NÃ£o use `print()`. NÃ£o inclua os marcadores de cÃ³digo ```python ou ```.
#                     """
# 
#                     resposta_gemini = model.generate_content(prompt_gerador_codigo)
#                     codigo_gerado = resposta_gemini.text.strip()
# 
#                     st.write("CÃ³digo de anÃ¡lise gerado pelo Gemini:")
#                     st.code(codigo_gerado, language='python')
# 
#                     try:
#                         namespace = {'df': df}
#                         exec(codigo_gerado, namespace)
#                         resultado_bruto = namespace['resultado']
# 
#                         st.success("CÃ³digo executado com sucesso!")
#                         st.write("Resultado da anÃ¡lise (bruto):")
#                         st.write(resultado_bruto)
# 
#                         st.info("Agente: Usando Gemini para criar uma resposta final clara...")
# 
#                         prompt_sintetizador = f"""
#                         VocÃª Ã© um assistente de IA prestativo.
#                         Com base na pergunta original do usuÃ¡rio e no resultado da anÃ¡lise de dados, forneÃ§a uma resposta clara e concisa em portuguÃªs.
# 
#                         Pergunta Original: "{pergunta_usuario}"
#                         Resultado da AnÃ¡lise: "{resultado_bruto}"
# 
#                         Sua Resposta:
#                         """
# 
#                         resposta_final_gemini = model.generate_content(prompt_sintetizador)
#                         resposta_final = resposta_final_gemini.text
# 
#                         st.markdown("---")
#                         st.header("âœ… Resposta do Agente:")
#                         st.markdown(f"### {resposta_final}")
# 
#                     except Exception as e:
#                         st.error(f"Ocorreu um erro ao executar o cÃ³digo gerado: {e}")
#                         st.warning("O Agente pode ter gerado um cÃ³digo invÃ¡lido. Tente reformular sua pergunta.")
# 
#                 else:
#                     st.error("Nenhum arquivo .csv foi encontrado no .zip fornecido.")
#     else:
#         st.warning("Por favor, faÃ§a o upload de um arquivo .zip e digite uma pergunta.")

from pyngrok import ngrok
from google.colab import userdata

# Pega o authtoken do Secrets do Colab (esta parte jÃ¡ estÃ¡ funcionando!)
NGROK_TOKEN = userdata.get('NGROK_AUTHTOKEN')
ngrok.set_auth_token(NGROK_TOKEN)

# Inicia o streamlit em background
!streamlit run app.py &>/dev/null&

# Abre um tÃºnel para a porta 8501 usando a SINTAXE CORRETA
# A mudanÃ§a estÃ¡ nesta linha:
public_url = ngrok.connect(8501)

print("ğŸš€ SUCESSO! O Agente estÃ¡ no ar!")
print(f"âœ… Clique no link para acessar a interface: {public_url}")